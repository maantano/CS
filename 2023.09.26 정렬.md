2023.09.26

# 정렬

## 정렬이란

데이터를 특정한 기준에 따라서 순서대로 나열하는것을 말한다.

## 선택정렬

데이터가 무작위로 여러 개 있을 때, 이중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복한다.

가장 원시적인 방법으로 '매번 가장 작은것을 선택'한다는 의미에서 선택 정렬 알고리즘이라고 한다.

```py
arr = [7,5,9,0,3,1,6,2,4,8]

for i in range(len(arr)):
  min_idx = i
  for j in range(i+1,len(arr)):
    if arr[min_idx] > arr[j]:
      min_idx = j
      arr[i],arr[min_idx] = arr[min_idx],arr[i]
  print(arr)
```

스와프 코드

```py
  arr[i],arr[j] = arr[j],arr[i]
```

## 삽입 정렬

선택 정렬은 알고리즘 문제 풀이에 사용하기에는 느린편이다.
'데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하면 어떨까?'

선택 정렬은 현재 데이터의 상태와 상관 없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면 삽입 정렬은 그렇지 않다.
삽입 정렬은 특정한 데이터를 적절한 위치에 '삽입'한다는 의미에서 *삽입 정렬*이라고 부른다.
삽입 정렬은 특정한 데이터가 절절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징이다.

삽입 정렬의 특징은, 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다는 점이다. 이러한 특징 때문에 삽입 정렬에서는 특정한 데이터가 삽입될 위치를 선정할 때(삽입될 위치를 찾기 위하여 왼쪽으로 한 칸씩 이동할 때)
삽입될 데이터보다 작은 데이터를 만나면 그 위치에서 멈추면 된다.

예를 들어
0 5 7 9 3
마지막 3이 자리를 찾을때 3의 왼쪽 원소들은 모두 정렬이 되어있다고 가정을 하기 때문에 처음에 0을 확인했을때 자리를 찾으려는 3보다 작은 요소를 만나면 바로 멈추고 작은 요소 오른쪽에 넣으면 된다.

```py
arr = [7,5,9,0,3,1,6,2,4,8]

for i in range(1,len(arr)):
  for j in range(i,0,-1): # 인덱스 i 부터 1까지 감소하며 반복
    if arr[j] < arr[j-1]:
      arr[j],arr[j-1] = arr[j-1],arr[j]
    else:
      break
print(arr)
```

- range의 세 번째 매개 변수
  - range의 매개 변수는 3개(start,end,step)이다. 세 번째 매개 변수인 step에 -1이 들어가면 start 인덱스 부터 시작해서 end+1 인덱스 까지 1씩 감소한다. 앞의 코드에서는 j 변수가 i 부터 1 까지 1씩 감소한다.

## 퀵 정렬

정렬 알고리즘 중 가장 많이 사용되는 알고리즘 이다.
'기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까?'
퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
퀵 정렬에서는 피벗이 사용된다.
_큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 피벗이라고 한다._
퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 한다.
피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러 가지 방식으로 퀵 정렬을 구분하는데 대표적인 분할 방식인 호어 분할 방식으로 사용하겠다.

호어 분할 방식에는 규칙이 있는데

- 리스트에서 첫 번째 데이터를 피벗으로 정한다.

피벗을 설정한 뒤에는 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다.
이러한 과정을 반복하면 '피벗'에 대하여 정렬이 수행된다.
왼쪽에서 찾는 값과 오른쪽에서 찾는 값이 겹쳐질때 겹쳐진 왼쪽값의 위치와 피벗의 위치를 변경하고 피벗을 작은 수로 만든다.
이 과정을 반복한다.

```py
arr = [5,7,9,0,3,1,6,2,4,8]

def quick_sort(arr,start,end):
  if start >= end: # 원소가 한개인 경우 종료
    return
  pivot = start
  left = start + 1
  right = end

  while left <= right:
    #피벗보다 큰 데이터를 찾을 떄 까지 반복
    while left <= end and arr[left] <= arr[pivot]
      left+=1
    while rigth >= start and arr[right] >= arr[pivot]
      right -= 1
    if left > right:
      arr[right],arr[pivot] = arr[pivot],arr[right]
    else:
      arr[left],arr[right] = arr[right],arr[left]

    quick_sort(arr,start,right-1)
    quick_sort(arr,right+1,end)

quick_sort(arr,0,len(arr)-1)
print(arr)
```

```py
arr = [5,7,9,0,3,1,6,2,4,8]

def quick_sort(arr):
  if len(arr) <= 1:
    return arr
  pivot = arr[0]
  tail = arr[1::] # 피벗을 제외한 리스트

  left_side = [x for x in tail if x <= pivot]
  right_side = [x for x in tail if x > pivot]

  return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(arr))
```

## 계수 정렬

계수 정렬 알고리즘은 _특정한 조건이 부합할 때만 사용할 수 있지만_ 매우 빠른 정렬 알고리즘이다.
계수 정렬은 '데이터 크기 범위가 제한 되어 정수형태로 표현할 수 있을 때!' 에만 사용할 수 있다.
예를 들어 데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 계수 정렬은 사용하기 어렵다.
가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
예를 들어 0이상 100이하인 성적 데이터를 정렬할 때 계수 정렬이 효과적이다.
계수정렬을 이용할 때는 모든 범위를 담을 수 있는 크기의 리스트를 선언해야 하기 때문이다.
예를 들어 가장 큰 데이터와 가장 자은 데이터으 ㅣ차이가 1,000,000이라면 1,000,001 개의 데이터가 들어갈 수 있는 리스트를 초기화 해야한다.
계수 정렬은 앞서 다루었던 3가지 정렬 알고리즘 처럼 직접 데이터의 값을 비교한 뒤에 위치를 변경하여 정렬하는(비교 기반의 정렬 알고리즘) 방식이 아니다.

배열에 들어있는 요소들을 확인 검사해가며 초기화된 리스트에 해당요소의 갯수를 카운트하고 모든 요소를 검사했을때 리스트의 갯수만큼 출력해주면 된다.

```py
arr = [7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]

count = [0] *(max(arr)+1)

for i in range(len(arr)):
  count[arr[i]] += 1

for i in range(len(count)):
  for j in range(count[i]):
    print(i, end =' ')
```

## 파이썬의 정렬 라이브러리

파이썬은 기본 정렬 라이브러리인 sorted() 함수를 제공한다. sorted()는 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌는데, 병합 정렬은 일반적으로 퀵 정렬보다 느리지만 시간 복잡도 O(NlogN)을 보장한다.
